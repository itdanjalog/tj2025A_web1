[ HTTP ] HyperText Transfer Protocol
	- 문자 이동 프로토콜 : 객체지향 아니므로 문자 또는 바이너리(바이트) 자료만 통신이 가능하다.
	1. 정의 : 웹 에서 사용하는 문자 통신 규약
	2. 특징
		1. 무상태 프로로콜 ( 상태 없고 -> 저장기능 없다 )
		2. 독립적 , 이전 요청 과 다음 요청은 다르다
		3. TCP/IP 프로토콜의 종속되어 동작 PORT 80/8080 사용한다. http://ip:port
	3. 주소 체계
		URL : 웹 주소 , 네트워크 상의 자료가 어디에 있는지 위치를 표시하는 규약
			http://ip:port/자료위치
			https://nid.naver.com/nidlogin.login : 네이버의 login(html) 이 위치한 주소
		URI : 각종 자료들의 유일한 이름이나 위치를 표시하는 규약 , URL + 매개변수명 = 값
			http://ip/port/자료위치?매개변수1=값1&매개변수2=값2
			https://finance.naver.com/item/main.naver?code=005930
			(URL) https://finance.naver.com/item/main.naver
			(URI) https://finance.naver.com/item/main.naver?code=005930

	4. HTTP Header ( HTTP 통신 정보/내용가 들어있는 곳  )
		[ 주요 ]
		1. HTTP ***METHOD*** : HTTP 이용한 통신 요청할 때 분류 하는 규칙 * 과거에는 GET 방식으로 만 통신 했지만 현재는 다양한 방식을 제공한다.
		2. HTTP ***BODY*** : HTTP 이용하여 데이터의 내용/본문 보낼때 사용되는 규칙
		3. HTTP Content-Type : HTTP 이용한 데이터의 타입 정보
		4. HTTP HOST : HTTP 이용한 통신 요청하는 서버의 URL 주소

	5. HTTP METHOD 종류 	  CRUD			HTTP기반의 연결(매핑)구축(RESTFUL)
		1. get 			: Read			@GetMapping()
		2. post			: Create		@PostMapping()
		3. put 			: Update		@PutMapping()
		4. delete 		: Delete		@DeleteMapping()

	6. HTTP 사용처 :
		1. (사용자) 브라우저( 크롬,엣지,사파리 등등) 상단에 HTTP 입력한다. 브라우저 상단 주소 입력창은 GET 방식 이다.
		2. (개발자) Talend Api ( restful test )
		3. ( JS ) fetch, ajax(JQUERY) , axios(REACT) 등등 : JS가 제공하는 HTTP 통신 라이브러리

	7. HTTP 가 데이터를 보내는 방법
		예] 우체국에 편지(통신) 보낸다. 편지봉투( 보낸사람,받는사람 = url / queryString ), 편지지( 내용물 = body )
		방법1. 쿼리스트링
			1. 정의 : url 주소상의 '?'물음표 구분하여 매개변수명 = 값 표시하고 여러개 일경우 '&'(엔퍼센트) 구분한다.
			2. 요청 : GET , POST , PUT , DELETE 메소드 에서 사용 가능. ( 보안상 좋지 않다. )
				예1]
				https://finance.naver.com/item/main.naver?code=005930
				(URL) https://finance.naver.com/item/main.naver
				(쿼리스트링) ?code=005930
					매개변수명은 code
					매개변수값은 005930
				예2]
				https://www.leelin.co.kr/shop/shopdetail.html?branduid=1168891&xcode=028
				(URL)https://www.leelin.co.kr/shop/shopdetail.html
				(쿼리스트링)
					매개변수명 : branduid ,	xcode
					매개변수값 : 1168891  ,	028

		방법2. HTTP header(정보) body
			1. 정의 : HTTP 요청 과 응답 내용 자체를 전달하는 역할
			2. 요청 : POST, PUT 메소드 지원/권장, ( 보안상 좋다. )
				1. content-type : application/json
			3. 응답 :
				1. HTTP 상태 메시지( 2XX:성공 , 4XX:프로토콜문제 , 5XX:서버문제 )

        방법3. HTTP header(정보) form
            1. 정의 : HTML <form> 태그를 이용해 데이터를 서버로 전송하는 방식, 브라우저에서 가장 기본적으로 제공하는 전송 방법
            2. 요청 방식 : 주로 POST 메소드 사용 (보안 및 데이터 용량 측면에서 권장), GET도 가능하지만, URL에 데이터가 그대로 노출되어 보안 취약
            3. Content-Type 종류
                1. application/x-www-form-urlencoded
                    - 폼 기본 전송 방식
                2. multipart/form-data
                    - 첨부파일 업로드 등 대용량 바이너리 데이터 전송 가능,   예) 이미지 업로드, PDF 첨부 등

 	8. HTTP Content-Type
 		1. 정의 : HTTP 의 요청 과 응답의 본문 데이터 형식 을 나타내는 HTTP header 정보 중 하나.
 		2. 목적 : 서버와 클라이언트가 데이터를 주고 받는데 있어서 형식 명시/표시 한다.
 		3. 주의 : HTTP는 기본적으로 문자열 자료만 가능하다.
 		4. 타입 종류 :
 			1. text/html							: html 문서
 			2. text/plain							: 일반 텍스트 데이터
 			3. application/json						: JSON 데이터
 			4. application/xml						: xml 데이터
 			5. application/x-www-form-urlencoded	: 폼 형식의 데이터 , html의 <form> 마크업
 			6. multipart/form-data					: 첨부파일 업로드 , 대용량 데이터(바이트) , formData

    9. HTTP 응답 코드
        1. 정의 : 응답자(서버)가 요청자(클라이언트)의 요청에 대한 결과를 나타내는 코드
        2. 종류 : [주로 많이 발생하는 코드]
            - 1xx : 요청을 받고 프로세스 계속 진행중.
            - 2xx : 요청을 받고 응답을 이해, 처리 완료
                200 : OK , 요청 성공 하고 응답 포함한다.
                201 : Create(저장)요청 성공 하고 응답 값을 포함한다.
                204 : 요청 성공 하고 응답 값 포함하지 하지 않는다.
            - 3xx : 요청을 완료하기 추가 조치 요구
            - 4xx : 클라이언트 오류
                400 : 서버가 이해할수 있는 요청    ( 쿼리스트링,body,매핑 등 오류 )
                401 : 서버가 요청에 따른 권한 없음
                403 : 서버가 요청에 따른 권한 거부
                404 : 서버가 요청에 따른 리소스(값/html/매핑 등) 찾을수 없을떄
                409 : 서버가 요청에 따른 값이 중복 일때 ( 아이디중복 등 )
            - 5xx : 서버 오류
                500 : 서버의 예기치 못한 오류 발생

[ 스프링 에서 응답 코드 전송/반환 ]
    1. ResponseEntity<T> : Spring 에서 HTTP 응답 객체를 제어할 수 있게 해주는 클래스
        * 참고 : < > 제네릭 타입은 기본타입 이 불가능하고 참조타입 가능하다.
    2. 형태
        ResponseEntity< 반환타입 > 메소드명( ) {
            return ResponseEntity.status( 응답코드 );
        }
    3. 방법
        1. ResponseEntity.status( 응답코드 ).body( 반환값 );
        2. ResponseEntity.status( 응답코드 ).build()